# Meeting 04.11.2022 - Progress

## Was haben wir gemacht

### Speicherstruktur:
- Den Entitities & Relations(Strings) wurden Integer als IDs zugewiesen
    - Aufsteigend positive Integer für Konstanten
    - Negative Integer von -1 bis -26 für Variablen (A, B, C, ..., X, Y, Z)
    - In Hashmap<String, Integer> gespeichert, für eventuelle Rückübersetzung oder falls Triple Queries in Textform kommen (Hierfür ausgelegt)

### Datenbankstruktur
**Bisher experimentell umgesetzt:**

**knowledgegraph**(subject, relation, object)

**knowledgegraph**(subject, relation, object) mit Index (relation, subject, object) —> als covering unclustered secondary Index --> da meistens alle attribute abgefragt werden

### Wie funktioniert eine Query:
(Als Query wird das Triple bezeichnet, zu dem die entsprechenden Regelen die das Triple impliziert, gefunden werden soll)

- Regelliste ist umgesetzt als Arraylist bestehend aus Head(Triple) und Body(Triple Liste) - Klassenstruktur mit Integer Attributen
- Wird per Stream vor-gefiltert:
    - Filter sind:
      - Relation der Query
      - Subject + Object falls sie eine Konstante im Head der Regel sind
      - Falls Subject + Object als Variablen im Head der Regel gleich sind z.B. r(X,X) <- ... aber Query: r(17, 4) impliziert ausschluss der Regel da 17 != 4

- Dann werden SQL-Queries erstellt nach dem Muster:
    - SELECT case when EXISTS(SELECT 1 FROM Knowledgegraph kg1, Knowledgegraph kg2… WHERE kg1.pre = … AND kg2.pre = … AND kg1.sub = sub AND ….) THEN {Rule} END;
    - Gibt die Regeln zurück bei denen alle passenden Triple des Bodys im Knowledgegraph sind
    - Alle Triple des Bodys werden hier alle in einem SELECT Statement auf Existenz im Knowledgegraph überprüft
    - Wichtige Verbesserung:
      - Für jede in Frage kommende Regel wird zurzeit noch eine SQL-Query einzeln abgesendet - wahrscheinlich Performance Einschränkung dadurch.
      - Umsetzung in einer großen SQL Query (oder mehreren großen aufgeteilt) durch UNION

### Messungen

  - Datensätze:
      - YAGO-3 - Test Datensatz: 5000 Triple
      - Regelmenge: 50 / 250 / 500 feste Regeln —> Keine Empty rules
      - Query Menge: 100 / 500 - random generiert - muss auch noch besser gemacht werden
  - Messung der Gesamtdauer
  - Messung der Durchschnittszeit pro Anfrage

- **50 Rules / 500 Queries:**
    - Indexed Knowledgegraph:
      - Einzeln:
        - Gesamtzeit: 2143ms
        - Durchschnittszeit: 4ms
      - UNION Umsetzung:
        - Gesamtzeit: 986 ms
        - Durchschnittszeit: 1 ms
    - Non-Indexed:
      - Einzeln:
        - Gesamtzeit: 3790 ms
        - Durchschnittszeit: 7 ms
      - UNION Umsetzung:
        - Gesamtzeit: 3057 ms
        - Durchschnittszeit: 6 ms


- **50 Rules / 100 Queries:**
    - Indexed Knowledgegraph:
      - Einzeln
        - Gesamtzeit: 628 ms
        - Durchschnittszeit: 6 ms
      - UNION Umsetzung
        - Gesamtzeit: 351 ms
        - Durchschnittszeit: 3 ms
    - Non-Indexed:
      - Einzeln:
        - Gesamtzeit: 1151 ms
        - Durchschnittszeit: 11 ms
      - UNION Umsetzung:
        - Gesamtzeit: 920 ms
        - Durchschnittszeit: 9 ms

- **250 Rules / 500 Queries:**
    - Indexed Knowledgegraph:
      - Einzeln:
        - Gesamtzeit: 5976 ms
        - Durchschnittszeit: 11 ms
      - UNION Umsetzung:
        - Gesamtzeit: 3417 ms
        - Durchschnittszeit: 6 ms
    - Non-Indexed:
      - Einzeln:
        - Gesamtzeit: 17980 ms
        - Durchschnittszeit: 35 ms
      - UNION Umsetzung:
        - Gesamtzeit: 14799 ms
        - Durchschnittszeit: 29 ms

- **250 Rules / 100 Queries:**
    - Indexed Knowledgegraph:
      - Einzeln
        - Gesamtzeit: 1796 ms
        - Durchschnittszeit: 17 ms
      - UNION Umsetzung:
        - Gesamtzeit: 885 ms
        - Durchschnittszeit: 8 ms
    - Non-Indexed:
      - Einzeln:
        - Gesamtzeit: 4745 ms
        - Durchschnittszeit: 47 ms
      - UNION Umsetzung:
        - Gesamtzeit: 2950 ms
        - Durchschnittszeit: 29 ms

## Next Steps

1. Optimierung des Vor-Filterns der Regelmenge durch parallel Streaming o. eventuell andere effizientere Methoden 

2. Bezüglich der Überprüfung in der Datenbank:
  - Da meistens der Body in unseren Beispielen nicht signifikant groß ist, wurde es so wie jetzt gemacht, aber:
    - ggf. effizienter wenn die Triple des Bodys per INTERSECT zusammengefügt aber jeweils einzeln überpüft werden oder per JOIN zusammengebracht, muss noch getested werden

3. Testen verschiedener Indizierungsmethoden    
    **knowledgegraph**(subject, relation, object) mit index (subject, relation, object) & index(relation) & index(relation, object) & index(relation, subject) —> Falls in der Anfrage nicht alle 3 Columns abgefragt werden, könnte diese Umsetzung sinvoll sein

    **knowledgegraph**(subject, relation, object) mit Primary Key (subject, relation, object) —> Clustered Primary Index, kann theoretisch durch höhere cache hits zu besserer performance führen (Das ist die Annahme)

5. Vollständige Umsetzung in der Datenbank
  - Regeln ebenfalls Teil der Datenbank statt Klassenstruktur
